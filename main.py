# Clean Project Setup Guide for Khatm Backend (Shia-focused)

"""
FINAL STRUCTURE:
================

backend/                        # This is your project root
‚îú‚îÄ‚îÄ src/                        # Source code
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ recitation.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ portion.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connection.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ init_db.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin_service.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ security.py
‚îÇ       ‚îî‚îÄ‚îÄ validators.py
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ API.md
‚îÇ   ‚îî‚îÄ‚îÄ DEPLOYMENT.md
‚îÇ
‚îú‚îÄ‚îÄ pyproject.toml              # ONLY ONE - at project root
‚îú‚îÄ‚îÄ uv.lock                     # Auto-generated by uv
‚îú‚îÄ‚îÄ .env                        # Your environment variables
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ recitations.db              # SQLite database (auto-created)
"""

# =============================================================================
# src/services/admin_service.py
# =============================================================================

ADMIN_SERVICE = """
import json
import sqlite3
from fastapi import HTTPException
from src.models.recitation import ContentTypeCreate

class AdminService:
    @staticmethod
    def create_content_type(content_type: ContentTypeCreate, user_id: int, conn) -> dict:
        '''Create a new content type'''
        try:
            # Convert dict to JSON string for storage
            portion_types_json = json.dumps(content_type.default_portion_types)
            
            conn.execute(
                '''INSERT INTO content_types (name, display_name, description, default_portion_types, created_by) 
                   VALUES (?, ?, ?, ?, ?)''',
                (content_type.name, content_type.display_name, content_type.description, 
                 portion_types_json, user_id)
            )
            conn.commit()
            
            cursor = conn.execute("SELECT id FROM content_types WHERE name = ?", (content_type.name,))
            content_type_id = cursor.fetchone()[0]
            
            return {
                "id": content_type_id,
                "name": content_type.name,
                "message": "Content type created successfully"
            }
        except sqlite3.IntegrityError:
            raise HTTPException(status_code=400, detail="Content type with this name already exists")
    
    @staticmethod
    def list_content_types(conn, include_inactive: bool = False) -> list:
        '''List all content types'''
        if include_inactive:
            cursor = conn.execute(
                "SELECT id, name, display_name, description, default_portion_types, is_active, created_at FROM content_types"
            )
        else:
            cursor = conn.execute(
                "SELECT id, name, display_name, description, default_portion_types, is_active, created_at FROM content_types WHERE is_active = 1"
            )
        
        types = []
        for row in cursor.fetchall():
            type_dict = dict(row)
            # Parse JSON string back to dict
            if type_dict['default_portion_types']:
                try:
                    type_dict['default_portion_types'] = json.loads(type_dict['default_portion_types'])
                except json.JSONDecodeError:
                    type_dict['default_portion_types'] = {}
            types.append(type_dict)
        
        return types
    
    @staticmethod
    def update_content_type(content_type_id: int, updates: dict, conn) -> dict:
        '''Update a content type'''
        allowed_fields = ['display_name', 'description', 'default_portion_types', 'is_active']
        update_parts = []
        values = []
        
        for field, value in updates.items():
            if field in allowed_fields:
                if field == 'default_portion_types':
                    value = json.dumps(value)
                update_parts.append(f"{field} = ?")
                values.append(value)
        
        if not update_parts:
            raise HTTPException(status_code=400, detail="No valid fields to update")
        
        values.append(content_type_id)
        query = f"UPDATE content_types SET {', '.join(update_parts)} WHERE id = ?"
        
        result = conn.execute(query, values)
        conn.commit()
        
        if result.rowcount == 0:
            raise HTTPException(status_code=404, detail="Content type not found")
        
        return {"message": "Content type updated successfully"}
    
    @staticmethod
    def toggle_content_type(content_type_id: int, conn) -> dict:
        '''Activate or deactivate a content type'''
        cursor = conn.execute("SELECT is_active FROM content_types WHERE id = ?", (content_type_id,))
        result = cursor.fetchone()
        
        if not result:
            raise HTTPException(status_code=404, detail="Content type not found")
        
        new_status = 0 if result[0] else 1
        conn.execute("UPDATE content_types SET is_active = ? WHERE id = ?", (new_status, content_type_id))
        conn.commit()
        
        return {
            "message": f"Content type {'activated' if new_status else 'deactivated'} successfully",
            "is_active": bool(new_status)
        }
"""

# =============================================================================
# src/routers/admin.py
# =============================================================================

ADMIN_ROUTER = """
from fastapi import APIRouter, Depends, Query
from src.models.recitation import ContentTypeCreate
from src.services.admin_service import AdminService
from src.database.connection import get_db
from src.utils.security import security, verify_admin

router = APIRouter(prefix="/admin", tags=["Admin"])

@router.post("/content-types")
async def create_content_type(
    content_type: ContentTypeCreate, 
    conn = Depends(get_db),
    user_id: int = Depends(lambda c=Depends(get_db): verify_admin(Depends(security), c))
):
    '''Create a new content type (Admin only)'''
    return AdminService.create_content_type(content_type, user_id, conn)

@router.get("/content-types")
async def list_content_types(
    include_inactive: bool = Query(False, description="Include inactive content types"),
    conn = Depends(get_db)
):
    '''List all content types (Public endpoint)'''
    return {"content_types": AdminService.list_content_types(conn, include_inactive)}

@router.patch("/content-types/{content_type_id}")
async def update_content_type(
    content_type_id: int,
    updates: dict,
    conn = Depends(get_db),
    user_id: int = Depends(lambda c=Depends(get_db): verify_admin(Depends(security), c))
):
    '''Update a content type (Admin only)'''
    return AdminService.update_content_type(content_type_id, updates, conn)

@router.post("/content-types/{content_type_id}/toggle")
async def toggle_content_type(
    content_type_id: int,
    conn = Depends(get_db),
    user_id: int = Depends(lambda c=Depends(get_db): verify_admin(Depends(security), c))
):
    '''Activate or deactivate a content type (Admin only)'''
    return AdminService.toggle_content_type(content_type_id, conn)
"""

# =============================================================================
# STEP-BY-STEP SETUP COMMANDS
# =============================================================================

"""
# 1. Create the project directory
mkdir backend
cd backend

# 2. Initialize UV project with Python 3.12+
uv init --name backend --no-readme --python 3.12

# 3. Remove the default hello.py if created
rm -f hello.py 2>/dev/null || true

# 4. Create the source structure
mkdir -p src/{models,database,routers,services,utils}
mkdir -p tests docs

# 5. Create all __init__.py files
touch src/__init__.py
touch src/models/__init__.py
touch src/database/__init__.py
touch src/routers/__init__.py
touch src/services/__init__.py
touch src/utils/__init__.py
touch tests/__init__.py

# 6. Add dependencies
uv add fastapi "uvicorn[standard]" pyjwt pydantic-settings

# 7. Add dev dependencies (optional)
uv add --dev pytest httpx ruff

# 8. Create environment file
cat > .env.example << 'EOF'
SECRET_KEY=change-this-to-a-secure-random-string
DATABASE_URL=recitations.db
TOKEN_EXPIRY_DAYS=30
EOF

# Copy to actual .env
cp .env.example .env

# 9. Create .gitignore
cat > .gitignore << 'EOF'
# Python
__pycache__/
*.py[cod]
*.so
.Python
*.egg-info/
dist/
build/

# UV
.venv/

# Environment
.env

# Database
*.db
*.sqlite

# IDE
.vscode/
.idea/
*.swp

# Testing
.pytest_cache/
.coverage
EOF

# 10. Now create your Python files (see code below)
"""

# =============================================================================
# pyproject.toml
# =============================================================================

PYPROJECT_TOML = """
[project]
name = "khatm-backend"
version = "1.0.0"
description = "Backend API for organizing collective recitation of Quran and Shia texts (Khatm)"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",
    "pyjwt>=2.9.0",
    "pydantic-settings>=2.6.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "httpx>=0.27.0",
    "ruff>=0.8.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
line-length = 100
target-version = "py312"

[tool.ruff.lint]
select = ["E", "F", "I"]
"""

# =============================================================================
# README.md
# =============================================================================

README_MD = """
# Collective Recitation Backend API üìø

A modern backend service for organizing collective recitation of the Holy Quran and Islamic texts. This service enables communities to coordinate reading and completion tracking with detailed progress monitoring.

## üåü Features

- **Multi-text Support**: Quran, Sahifa Sajjadiya, Mafatih al-Jinan, Nahjul Balagha, and more
- **Flexible Authentication**: Login with email or phone number (international format)
- **Flexible Portions**: Juz, Hezb, Surah, page, or custom divisions
- **Progress Tracking**: Track completion percentage within each portion
- **Statistics**: View individual and group progress
- **Multi-language**: Support for Arabic, Farsi, Urdu, English, and more
- **Modern API**: Built with FastAPI, auto-generated documentation

## üöÄ Quick Start

### Prerequisites

- Python 3.12 or higher
- UV package manager

### Installation

```bash
# Install UV (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Clone and setup
git clone <repository-url>
cd backend

# Install dependencies
uv sync

# Set up environment variables
cp .env.example .env
# Edit .env and set your SECRET_KEY

# Run the server
uv run uvicorn src.main:app --reload
```

The API will be available at `http://localhost:8000`

## üìö API Documentation

Interactive API documentation is auto-generated and available at:

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

## üïå Supported Texts (Content Types)

The system comes with pre-configured content types, and **administrators can add new types dynamically** through the admin API.

### Pre-configured Content Types

### Holy Quran
- `quran` - The Holy Quran
  - Portion types: `juz` (30), `hezb` (60), `quarter` (240), `surah` (114), `page` (604)

### Shia Prayers and Supplications
- `sahifa_sajjadiya` - Al-Sahifa al-Sajjadiyya (Psalms of Islam)
  - Portion types: `dua` (54 supplications)
- `mafatih` - Mafatih al-Jinan
  - Portion types: `section`, `day` (custom)

### Hadith Collections
- `nahj_balagha` - Nahjul Balagha (Peak of Eloquence)
  - Portion types: `sermon`, `letter`, `saying`
- `al_kafi` - Al-Kafi
  - Portion types: `volume` (8), `book`, `chapter`
- `man_la_yahduruhu` - Man La Yahduruhu al-Faqih
  - Portion types: `volume` (4), `chapter`

### Ziyarat
- `ziyarat_ashura` - Ziyarat Ashura (40 days)
  - Portion types: `day` (40)
- `ziyarat_collection` - Various Ziyarat
  - Portion types: `ziyarat` (custom)

### Custom
- `custom` - Any other text or practice
  - Must specify `total_portions`

### Admin: Add New Content Types

Administrators can add new content types through the API:

```bash
POST /admin/content-types
Authorization: Bearer <admin-token>
{
  "name": "tafsir_tabari",
  "display_name": "Tafsir al-Tabari",
  "description": "Classical Quranic commentary by Imam al-Tabari",
  "default_portion_types": {
    "volume": 24,
    "part": 30
  }
}
```

## üìñ Basic Usage

### 1. Register a User

```bash
POST /auth/register
{
  "name": "Ali Hussain",
  "email": "ali@example.com",
  "password": "securepassword",
  "preferred_language": "ar"
}
```

### 2. Create a Recitation Session

```bash
POST /recitations
Authorization: Bearer <token>
{
  "title": "Quran Recitation - Muharram 1446",
  "description": "Complete Quran recitation for Imam Hussain (AS)",
  "content_type": "quran",
  "portion_type": "juz",
  "language": "ar"
}
```

### 3. Join and Claim a Portion

```bash
POST /recitations/{id}/join
POST /recitations/{id}/assign
{
  "portion_number": 5
}
```

### 4. Update Progress

```bash
PUT /recitations/{id}/portions/{number}/progress
{
  "progress_percentage": 50,
  "notes": "Completed half of the Juz"
}
```

## üèóÔ∏è Project Structure

```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ models/         # Pydantic models (data validation)
‚îÇ   ‚îú‚îÄ‚îÄ database/       # Database connection and initialization
‚îÇ   ‚îú‚îÄ‚îÄ routers/        # API endpoints
‚îÇ   ‚îú‚îÄ‚îÄ services/       # Business logic
‚îÇ   ‚îî‚îÄ‚îÄ utils/          # Helper functions
‚îú‚îÄ‚îÄ tests/              # Unit tests
‚îú‚îÄ‚îÄ docs/               # Additional documentation
‚îî‚îÄ‚îÄ pyproject.toml      # Project configuration
```

## üîí Security

- Passwords are hashed using SHA-256
- JWT tokens for authentication (30-day expiry)
- Phone number validation (international format)
- Environment-based configuration

## üåç Multi-language Support

Supported languages:
- `ar` - Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©)
- `fa` - Farsi (ŸÅÿßÿ±ÿ≥€å)
- `ur` - Urdu (ÿßÿ±ÿØŸà)
- `en` - English
- `tr` - Turkish (T√ºrk√ße)
- `az` - Azerbaijani (Az…ôrbaycan)

The backend stores language preferences. Actual translations should be handled in your frontend application.

## üö¢ Deployment

### Development
```bash
uv run uvicorn src.main:app --reload --host 0.0.0.0 --port 8000
```

### Production
```bash
# Generate a secure secret key
export SECRET_KEY=$(python -c "import secrets; print(secrets.token_hex(32))")

# Use PostgreSQL in production (recommended)
export DATABASE_URL="postgresql://user:pass@localhost/khatm"

# Run with Gunicorn
uv run gunicorn src.main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

See `docs/DEPLOYMENT.md` for detailed deployment instructions.

## üß™ Testing

```bash
# Run tests
uv run pytest

# With coverage
uv run pytest --cov=src tests/
```

## ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## üìÑ License

This project is open source and available under the MIT License.

## üôè Acknowledgments

This project is created to facilitate spiritual practices and strengthen community bonds through collective worship. 

**Ya Ali (AS) Madad** ü§≤

---

For detailed API documentation, see `docs/API.md`
"""

# =============================================================================
# docs/API.md
# =============================================================================

API_MD = """
# API Documentation

## Authentication Endpoints

### POST /auth/register
Register a new user.

**Request Body:**
```json
{
  "name": "Ali Hussain",
  "email": "ali@example.com",
  "phone": "+989123456789",
  "password": "securepassword",
  "preferred_language": "ar"
}
```

**Response:**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user_id": 1,
  "message": "User registered successfully"
}
```

### POST /auth/login
Login with email or phone.

**Request Body:**
```json
{
  "email": "ali@example.com",
  "password": "securepassword"
}
```

**Response:**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user_id": 1
}
```

## Khatm Endpoints

All endpoints below require authentication. Include the JWT token in the Authorization header:
```
Authorization: Bearer <your-token>
```

### POST /khatms
Create a new Khatm.

**Request Body:**
```json
{
  "title": "Sahifa Sajjadiya - Arbaeen 2024",
  "description": "Complete recitation during Arbaeen",
  "content_type": "sahifa_sajjadiya",
  "portion_type": "dua",
  "language": "ar",
  "deadline": "2024-09-15T23:59:59"
}
```

**Response:**
```json
{
  "khatm_id": 1,
  "total_portions": 54,
  "message": "Khatm created successfully"
}
```

### GET /khatms
List all active Khatms.

**Response:**
```json
{
  "khatms": [
    {
      "id": 1,
      "title": "Quran Khatm - Muharram",
      "creator_name": "Ali Hussain",
      "content_type": "quran",
      "portion_type": "juz",
      "total_portions": 30,
      "participant_count": 15,
      "completed_count": 8,
      "average_progress": 45.5,
      "status": "active",
      "created_at": "2024-01-05T10:00:00"
    }
  ]
}
```

### GET /khatms/{id}
Get detailed information about a specific Khatm.

### POST /khatms/{id}/join
Join a Khatm.

### POST /khatms/{id}/assign
Claim a portion.

**Request Body:**
```json
{
  "portion_number": 5
}
```

### PUT /khatms/{id}/portions/{number}/progress
Update progress on a portion.

**Request Body:**
```json
{
  "progress_percentage": 75,
  "notes": "Completed up to page 90"
}
```

### PUT /khatms/{id}/portions/{number}/complete
Mark a portion as complete (shortcut for 100% progress).

### GET /khatms/{id}/portions/{number}/history
View progress history for a portion.

### GET /khatms/{id}/stats
Get statistics for a Khatm.

**Response:**
```json
{
  "total_portions": 30,
  "completed_portions": 12,
  "active_participants": 8,
  "average_progress": 58.3,
  "completion_percentage": 40.0
}
```

### GET /users/me/stats
Get current user's statistics.

**Response:**
```json
{
  "khatms_joined": 3,
  "portions_assigned": 8,
  "portions_completed": 5,
  "average_progress": 72.5
}
```

## Content Types Reference

| Content Type | Description | Common Portion Types |
|-------------|-------------|---------------------|
| `quran` | Holy Quran | juz, hezb, quarter, surah, page |
| `sahifa_sajjadiya` | Al-Sahifa al-Sajjadiyya | dua (54) |
| `mafatih` | Mafatih al-Jinan | section, day |
| `nahj_balagha` | Nahjul Balagha | sermon, letter, saying |
| `al_kafi` | Al-Kafi | volume (8), book, chapter |
| `man_la_yahduruhu` | Man La Yahduruhu al-Faqih | volume (4), chapter |
| `ziyarat_ashura` | Ziyarat Ashura | day (40) |
| `ziyarat_collection` | Various Ziyarat | ziyarat |
| `custom` | Custom text | Must specify total_portions |

## Error Responses

All errors follow this format:

```json
{
  "detail": "Error message here"
}
```

Common HTTP status codes:
- `400` - Bad Request (validation error)
- `401` - Unauthorized (invalid/missing token)
- `403` - Forbidden (not allowed)
- `404` - Not Found
- `500` - Internal Server Error
"""

# =============================================================================
# docs/DEPLOYMENT.md
# =============================================================================

DEPLOYMENT_MD = """
# Deployment Guide

## Production Checklist

### 1. Environment Variables

Create a `.env` file with secure values:

```bash
# Generate a secure secret key
python -c "import secrets; print(secrets.token_hex(32))"

# Add to .env
SECRET_KEY=<generated-key>
DATABASE_URL=postgresql://user:password@localhost/khatm_db
TOKEN_EXPIRY_DAYS=30
```

### 2. Database

#### PostgreSQL (Recommended for Production)

```bash
# Install PostgreSQL
sudo apt-get install postgresql postgresql-contrib

# Create database
sudo -u postgres createdb khatm_db
sudo -u postgres createuser khatm_user
sudo -u postgres psql -c "ALTER USER khatm_user WITH PASSWORD 'secure_password';"
sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE khatm_db TO khatm_user;"

# Update requirements
uv add psycopg2-binary

# Update connection.py to use PostgreSQL
```

#### SQLite (Development/Small Deployments)

SQLite is fine for development and small deployments. No additional setup needed.

### 3. Web Server

#### Using Gunicorn + Nginx

```bash
# Install Gunicorn
uv add gunicorn

# Run with Gunicorn
uv run gunicorn src.main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 127.0.0.1:8000

# Nginx configuration
server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 4. Systemd Service

Create `/etc/systemd/system/khatm-backend.service`:

```ini
[Unit]
Description=Khatm Backend API
After=network.target

[Service]
Type=notify
User=www-data
Group=www-data
WorkingDirectory=/var/www/khatm-backend
Environment="PATH=/var/www/khatm-backend/.venv/bin"
ExecStart=/var/www/khatm-backend/.venv/bin/gunicorn src.main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 127.0.0.1:8000

[Install]
WantedBy=multi-user.target
```

Enable and start:
```bash
sudo systemctl enable khatm-backend
sudo systemctl start khatm-backend
```

### 5. SSL Certificate

```bash
# Install Certbot
sudo apt-get install certbot python3-certbot-nginx

# Get certificate
sudo certbot --nginx -d your-domain.com
```

### 6. CORS Configuration

If your frontend is on a different domain, add CORS middleware in `src/main.py`:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://your-frontend-domain.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## Docker Deployment

### Dockerfile

```dockerfile
FROM python:3.12-slim

WORKDIR /app

# Install UV
RUN pip install uv

# Copy project files
COPY pyproject.toml uv.lock ./
COPY src ./src

# Install dependencies
RUN uv sync --frozen

# Expose port
EXPOSE 8000

# Run application
CMD ["uv", "run", "gunicorn", "src.main:app", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "--bind", "0.0.0.0:8000"]
```

### docker-compose.yml

```yaml
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "8000:8000"
    environment:
      - SECRET_KEY=${SECRET_KEY}
      - DATABASE_URL=postgresql://khatm:password@db:5432/khatm_db
    depends_on:
      - db

  db:
    image: postgres:16
    environment:
      - POSTGRES_USER=khatm
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=khatm_db
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

Run with:
```bash
docker-compose up -d
```

## Monitoring

### Health Check Endpoint

Add to `src/main.py`:

```python
@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

### Logging

Configure logging in production:

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/khatm-backend/app.log'),
        logging.StreamHandler()
    ]
)
```

## Backup

### Database Backup Script

```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="/var/backups/khatm"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# PostgreSQL backup
pg_dump -U khatm_user khatm_db > "$BACKUP_DIR/khatm_$TIMESTAMP.sql"

# Keep only last 7 days
find $BACKUP_DIR -name "khatm_*.sql" -mtime +7 -delete
```

Add to crontab:
```bash
0 2 * * * /path/to/backup.sh
```

## Performance Optimization

1. **Use connection pooling** for database
2. **Enable caching** for frequently accessed data
3. **Use CDN** for static assets
4. **Implement rate limiting** to prevent abuse
5. **Monitor with tools** like Prometheus + Grafana
"""

# =============================================================================
# src/config.py
# =============================================================================

CONFIG_PY = """
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Collective Recitation API"
    version: str = "1.0.0"
    secret_key: str = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
    database_url: str = os.getenv("DATABASE_URL", "recitations.db")
    token_expiry_days: int = 30
    
    class Config:
        env_file = ".env"

settings = Settings()
"""

# =============================================================================
# src/database/connection.py
# =============================================================================

CONNECTION_PY = """
import sqlite3
from typing import Generator
from src.config import settings

def get_db() -> Generator:
    conn = sqlite3.connect(settings.database_url)
    conn.row_factory = sqlite3.Row
    try:
        yield conn
    finally:
        conn.close()
"""

# =============================================================================
# src/database/init_db.py
# =============================================================================

INIT_DB_PY = """
import sqlite3
from src.config import settings

def init_database():
    conn = sqlite3.connect(settings.database_url)
    c = conn.cursor()
    
    c.execute('''CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE,
        phone TEXT UNIQUE,
        password_hash TEXT NOT NULL,
        preferred_language TEXT DEFAULT 'en',
        is_admin BOOLEAN DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )''')
    
    # Content types table - allows dynamic addition of new types
    c.execute('''CREATE TABLE IF NOT EXISTS content_types (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        display_name TEXT NOT NULL,
        description TEXT,
        default_portion_types TEXT,
        is_active BOOLEAN DEFAULT 1,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users(id)
    )''')
    
    # Seed default content types
    default_types = [
        ('quran', 'Holy Quran', 'The Holy Quran', '{"juz":30,"hezb":60,"quarter":240,"surah":114,"page":604}'),
        ('sahifa_sajjadiya', 'Al-Sahifa al-Sajjadiyya', 'Psalms of Islam', '{"dua":54}'),
        ('mafatih', 'Mafatih al-Jinan', 'Keys to the Gardens', '{}'),
        ('nahj_balagha', 'Nahjul Balagha', 'Peak of Eloquence', '{"sermon":241,"letter":79,"saying":480}'),
        ('al_kafi', 'Al-Kafi', 'The Sufficient', '{"volume":8}'),
        ('man_la_yahduruhu', 'Man La Yahduruhu al-Faqih', 'For One Not in the Presence of a Jurist', '{"volume":4}'),
        ('ziyarat_ashura', 'Ziyarat Ashura', 'Ziyarat of Imam Hussain (AS)', '{"day":40}'),
        ('custom', 'Custom', 'Custom content type', '{}'),
    ]
    
    for name, display, desc, portions in default_types:
        c.execute(
            'INSERT OR IGNORE INTO content_types (name, display_name, description, default_portion_types) VALUES (?, ?, ?, ?)',
            (name, display, desc, portions)
        )
    
    c.execute('''CREATE TABLE IF NOT EXISTS recitations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT,
        creator_id INTEGER NOT NULL,
        content_type_id INTEGER NOT NULL,
        portion_type TEXT NOT NULL,
        total_portions INTEGER NOT NULL,
        status TEXT DEFAULT 'active',
        language TEXT DEFAULT 'en',
        deadline TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (creator_id) REFERENCES users(id),
        FOREIGN KEY (content_type_id) REFERENCES content_types(id)
    )''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS participants (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        recitation_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (recitation_id) REFERENCES recitations(id),
        FOREIGN KEY (user_id) REFERENCES users(id),
        UNIQUE(recitation_id, user_id)
    )''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS portions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        recitation_id INTEGER NOT NULL,
        user_id INTEGER,
        portion_number INTEGER NOT NULL,
        progress_percentage INTEGER DEFAULT 0,
        is_completed BOOLEAN DEFAULT 0,
        assigned_at TIMESTAMP,
        completed_at TIMESTAMP,
        last_progress_update TIMESTAMP,
        FOREIGN KEY (recitation_id) REFERENCES recitations(id),
        FOREIGN KEY (user_id) REFERENCES users(id),
        UNIQUE(recitation_id, portion_number)
    )''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS progress_notes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        portion_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        progress_percentage INTEGER NOT NULL,
        notes TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (portion_id) REFERENCES portions(id),
        FOREIGN KEY (user_id) REFERENCES users(id)
    )''')
    
    conn.commit()
    conn.close()
"""

# =============================================================================
# src/models/user.py
# =============================================================================

USER_MODEL = """
from pydantic import BaseModel, EmailStr, field_validator
from typing import Optional
import re

class UserRegister(BaseModel):
    name: str
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    password: str
    preferred_language: str = "en"
    
    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v: str | None) -> str | None:
        if v is None:
            return v
        cleaned = re.sub(r'[\\s\\-\\(\\)]', '', v)
        if not re.match(r'^\\+[1-9]\\d{6,14}$', cleaned):
            raise ValueError('Phone number must be in international format (e.g., +989123456789)')
        return cleaned

class UserLogin(BaseModel):
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    password: str
    
    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v: str | None) -> str | None:
        if v is None:
            return v
        cleaned = re.sub(r'[\\s\\-\\(\\)]', '', v)
        if not re.match(r'^\\+[1-9]\\d{6,14}$', cleaned):
            raise ValueError('Phone number must be in international format')
        return cleaned
"""

# =============================================================================
# src/models/recitation.py
# =============================================================================

RECITATION_MODEL = """
from pydantic import BaseModel
from typing import Optional

class RecitationCreate(BaseModel):
    title: str
    description: Optional[str] = None
    content_type: str = "quran"
    portion_type: str = "juz"
    total_portions: Optional[int] = None
    deadline: Optional[str] = None
    language: str = "en"

class ContentTypeCreate(BaseModel):
    name: str
    display_name: str
    description: Optional[str] = None
    default_portion_types: dict[str, int] = {}
"""

# =============================================================================
# src/models/portion.py
# =============================================================================

PORTION_MODEL = """
from pydantic import BaseModel
from typing import Optional

class PortionAssign(BaseModel):
    portion_number: int

class PortionProgress(BaseModel):
    progress_percentage: int
    notes: Optional[str] = None
"""

# =============================================================================
# src/utils/security.py
# =============================================================================

SECURITY_PY = """
import hashlib
import jwt
from datetime import datetime, timedelta
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from src.config import settings

security = HTTPBearer()

def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()

def create_token(user_id: int) -> str:
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(days=settings.token_expiry_days)
    }
    return jwt.encode(payload, settings.secret_key, algorithm="HS256")

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> int:
    try:
        token = credentials.credentials
        payload = jwt.decode(token, settings.secret_key, algorithms=["HS256"])
        return payload["user_id"]
    except:
        raise HTTPException(status_code=401, detail="Invalid or expired token")

def verify_admin(credentials: HTTPAuthorizationCredentials = Depends(security), conn = None) -> int:
    '''Verify token and check if user is admin'''
    user_id = verify_token(credentials)
    
    if conn is None:
        raise HTTPException(status_code=500, detail="Database connection required")
    
    cursor = conn.execute("SELECT is_admin FROM users WHERE id = ?", (user_id,))
    result = cursor.fetchone()
    
    if not result or not result[0]:
        raise HTTPException(status_code=403, detail="Admin privileges required")
    
    return user_id
"""

# =============================================================================
# src/utils/validators.py
# =============================================================================

VALIDATORS_PY = """
from fastapi import HTTPException
from typing import Optional
import json

def get_portion_count(content_type: str, portion_type: str, custom_total: Optional[int], conn) -> int:
    '''Returns total number of portions based on content type and portion type.
    Checks database for dynamic content types first, falls back to hardcoded defaults.'''
    
    # Custom content types always require explicit total
    if content_type == "custom" or custom_total is not None:
        if custom_total is None:
            raise HTTPException(status_code=400, detail="total_portions required for custom content")
        return custom_total
    
    # Check database for content type
    cursor = conn.execute(
        "SELECT default_portion_types FROM content_types WHERE name = ? AND is_active = 1",
        (content_type,)
    )
    result = cursor.fetchone()
    
    if result and result[0]:
        try:
            portion_types = json.loads(result[0])
            if portion_type in portion_types:
                return portion_types[portion_type]
        except json.JSONDecodeError:
            pass
    
    # If no match in database or JSON, require custom total
    if custom_total is None:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported combination: {content_type}/{portion_type}. Please provide total_portions or contact admin to add this configuration."
        )
    
    return custom_total
"""
